{
	// Place your 全局 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"C++ 开头 OVO": {
		"scope": "cpp",
		"prefix": "#inc",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"// https://space.bilibili.com/672346917",
			"",
			"#ifndef LOCAL",
			"#define LOG(...) 42",
			"#endif",
			"",
			"#define fi first",
			"#define se second",
			"#define pb push_back",
			"#define endl '\\n'",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"",
			"typedef long long LL;",
			"typedef pair <int, int> PII;",
			"",
			"constexpr int inf = 0x3f3f3f3f;",
			"constexpr double EPS = 1e-8;",
			"const double PI = acos(-1);",
			"",
			"int multi_cases = 1;",
			"",
			"void A_SOUL_AvA () {",
			"    $0",
			"}",
			"",
			"int main () {",
			"    cin.tie(nullptr)->sync_with_stdio(false);",
			"    cout << fixed << setprecision(12);",
			"",
			"    int T = 1;",
			"    for (multi_cases && cin >> T; T; T--) {",
			"        A_SOUL_AvA ();",
			"    }",
			"",
			"    return 0;",
			"}",
		],
		"description": "C++ 开头"
	},

	"FastIO": {
		"scope": "cpp",
		"prefix": "FastIO",
		"body": [
			"/* ",
			"    note : do not use std::endl and do not sync_with_stdio(nullptr)",
			"    fin >> x; fout << x << \"\\n\";",
			"*/",
			"// #define endl '\\n'",
			"namespace FastIO { ",
			"    const int L = 1 << 22; char a[L], *l = a, *r = a, b[L], *p = b;",
			"    auto gc = [] () { if (l == r) r = (l = a) + fread(a, 1, L, stdin); return l == r ? EOF : *l++; };",
			"    auto pc = [] (char x) { if (p - b == L) fwrite(b, 1, L, stdout), p = b; *p++ = x; };",
			"    struct FastInstream {",
			"        FastInstream& operator >> (char &x) { while (isspace(x = gc())); return *this; }",
			"        template <typename T> FastInstream& operator >> (T &x) {",
			"            int f = 1; x = 0; char s = gc();",
			"            while (s < '0' || s > '9') { if (s == '-') f = -1; s = gc(); }",
			"            while (s <= '9' && s >= '0') x = x * 10 + (s ^ 48), s = gc();",
			"            x *= f;",
			"            return *this;",
			"        }",
			"    } fin;",
			"    struct FastOutstream {",
			"        ~FastOutstream() { fwrite(b, 1, p - b, stdout); }",
			"        FastOutstream& operator << (char x) { return pc (x), *this; }",
			"        FastOutstream& operator << (char *s) { while ( *s ) pc(*s++); return *this; }",
			"        FastOutstream& operator << (const char *s) { while ( *s ) pc(*s++); return *this; }",
			"        template <typename T> FastOutstream& operator << (T x) {",
			"            if(!x) { pc('0'); return *this; }",
			"            static char s[44]; int l = 0; if(x < 0) pc('-'), x = -x;",
			"            for(; x; x /= 10) s[l++] = x % 10; while (l) pc(s[--l] | 48);",
			"            return *this;",
			"        }",
			"    } fout;",
			"} ",
			"using FastIO::fout, FastIO::fin;",

		],
		"description": "FastIO"
	},

	"Debug": {
		"scope": "cpp",
		"prefix": "Debug",
		"body": [
			"namespace debugger {",
			"#ifdef DEBUG",
			"    template <typename T>",
			"    void __print_var(string_view name, const T & x) { std::cerr << name << \" = \" << x; }",
			"    void __print_var(string_view name, const string & x) { std::cerr << name << \" = \\\"\" << x << \"\\\"\"; }",
			"    void __print_var(string_view name, const char & x) { std::cerr << name << \" = \\'\" << x << \"\\'\"; }",
			"    template <typename T>",
			"    void __print_var(string_view name, const vector<T>& x) {",
			"        std::cerr << name << \" = \";",
			"        bool is_first = true;",
			"        for (auto & ele : x) std::cerr << (is_first ? (is_first = false, \"[\") : \", \") << ele;",
			"        std::cerr << \"]\";",
			"    }",
			"    template <typename T>",
			"    void __print_var(string_view name, const set<T>& x) {",
			"        std::cerr << name << \" = \";",
			"        bool is_first = true;",
			"        for (auto & ele : x) std::cerr << (is_first ? (is_first = false, \"{\") : \", \") << ele;",
			"        std::cerr << \"}\";",
			"    }",
			"    template <typename K, typename V>",
			"    void __print_var(string_view name, const map<K, V>& x) {",
			"        std::cerr << name << \" = \";",
			"        bool is_first = true;",
			"        for (auto & [k, v] : x) std::cerr << (is_first ? (is_first = false, \"{\") : \", \") << \"(\" << k << \": \" << v << \")\";",
			"        std::cerr << \"}\";",
			"    }",
			"    template <typename T>",
			"    void __log(string_view name, const T & x) {",
			"        __print_var(name, x); std::cerr << '\\n';",
			"    }",
			"    template <typename T, typename... Ts>",
			"    void __log(string_view name, const T & x, const Ts&... others) {",
			"        size_t pos = name.find(',');",
			"        __print_var(name.substr(0, pos), x); std::cerr << \", \";",
			"        __log(name.substr(pos + 1), others...);",
			"    }",
			" ",
			"#define LOG(args...)\\",
			"    { std::cerr << \"line \" << __LINE__ << \": \" << __func__ << \"(): \";\\",
			"    __log(#args, ##args); }",
			"#else",
			"#define LOG(...)",
			"#endif",
			"}",
			"using namespace debugger;",
		],
		"description": "namespace debug"
	},

	"Fenwick": {
		"scope": "cpp",
		"prefix": "FENW",
		"body": [
			"typedef long long LL;",
			"template <typename T>",
			"struct Fenwick {",
			"    vector <T> tr;",
			"    int N;",
			"    Fenwick (int _size = 100010): tr(_size), N(_size) {}",
			"    int lowbit(int x) { return x & -x; }",
			"    void modify(int x, T c) { assert(x > 0); for(int i = x; i < N; i += lowbit(i)) tr[i] += c; }",
			"    T query(int x) {",
			"        assert(x >= 0);",
			"        T res = 0;",
			"        for(int i = x; i; i -= lowbit(i)) res += tr[i];",
			"        return res;",
			"    } ",
			"    T query(int l, int r) { return query(r) - query(l - 1); } ",
			"};",
		],
		"description": "Fenwick Tree"
	},

	"DSU": {
		"scope": "cpp",
		"prefix": "DSU",
		"body": [
			"struct UF {",
			"    vector <int> f, cnt, d;",
			"    int blockSize, n;",
			"    UF(int _size = 100010): f(_size), cnt(_size), d(_size), blockSize(_size), n(_size) {",
			"        for(int i = 0; i < _size; i ++) ",
			"            f[i] = i, cnt[i] = 1, d[i] = 0;",
			"    }",
			"    int find(int x) {",
			"        if(f[x] == x) return x;",
			"        int root = find(f[x]);",
			"        d[x] += d[f[x]];",
			"        return f[x] = root;",
			"    }",
			"    int same(int a, int b) { return find(a) == find(b); }",
			"    // merge a to b",
			"    int merge(int a, int b, int op = 0) {",
			"        int fa = find(a), fb = find(b);",
			"        if(fa == fb) return 1;",
			"        --blockSize;",
			"        f[fa] = fb;",
			"        ",
			"        // info : d[a] = d[b] + 1 mod 2",
			"        d[fa] = d[b] - d[a] + op;",
			"        ",
			"        cnt[fb] += cnt[fa];",
			"        return 0;",
			"    }",
			"    int size(int a = 1) { return cnt[find(a)]; }",
			"    int chk(int x, int y, int op = 0) {",
			"        return (d[x] - d[y] + op) % 2;",
			"    }",
			"    int block(int _n) { // 返回 1 ~ _n 的连通块数量",
			"        return blockSize - (n - _n);",
			"    }",
			"};",
			
		],
		"description": "dsu"
	},

	"SegTree" : {
		"scope": "cpp",
		"prefix": "SEGTREE",
		"body": [
			"typedef long long LL;",
			"struct node {",
			"    // 节点信息",
			"    // 不要忘记初始化懒标记",
			"    ",
			"    int l, r;",
			"    /*",
			"    LL s = 0, g = 0;",
			"    node (int _l = 1, int _r = 1, LL _v = 0): l(_l), r(_r), s(_v) {}",
			"    */",
			"};",
			"",
			"struct SegTree{",
			"    /*",
			"        数据范围大的时候容易tle mle 尽量放在外面开",
			"        注意空间 不用 long long 的时候不要 long long",
			"    */",
			"",
			"    vector <node> tr;",
			"    vector <LL> a;",
			"    int n;",
			"",
			"    // 传入的 size 一定要大于 n ",
			"    SegTree(int _size = 100010): tr(_size << 2), a(_size), n(_size) {}",
			"",
			"    LL len (int u) { return 1ll * tr[u].r - tr[u].l + 1; }",
			"    LL len (node u) { return 1ll * u.r - u.l + 1; }",
			"",
			"    // 初始化某个点",
			"    void init(int u, LL c = 0) {",
			"        // tr[u].s = c, tr[u].g = c;",
			"    }",
			"    ",
			"    void pushup(node &u, node &l, node &r) {",
			"        ",
			"    }",
			"",
			"    void pushdown(node &u, node &l, node &r) {",
			"",
			"    }",
			"",
			"    void pushup(int u) { pushup(tr[u], tr[u << 1], tr[u << 1 | 1]); }",
			"",
			"    void pushdown(int u) { pushdown(tr[u], tr[u << 1], tr[u << 1 | 1]); }",
			"",
			"    void build(int u, int l, int r) {",
			"        tr[u] = {l, r};",
			"        init(u, a[r]);",
			"        if(l == r) return;",
			"        int mid = l + r >> 1;",
			"        build(u << 1, l, mid);",
			"        build(u << 1 | 1, mid + 1, r);",
			"        pushup(u);",
			"    }",
			"",
			"    /*",
			"        到了叶子节点就不要pushdown",
			"        tr[u].sum += len(u) * c;",
			"        tr[u].add += c;",
			"    */",
			"    void modify(int u, int l, int r, LL c) {",
			"        if(tr[u].l >= l && tr[u].r <= r) {",
			"",
			"            return;",
			"        }",
			"        pushdown(u);",
			"        int mid = tr[u].l + tr[u].r >> 1;",
			"        if(l <= mid) modify(u << 1, l, r, c);",
			"        if(r > mid) modify(u << 1 | 1, l, r, c);",
			"        pushup(u);",
			"    } ",
			"",
			"    node query(int u, int l, int r) {",
			"        if(tr[u].l >= l && tr[u].r <= r) {",
			"            return tr[u];",
			"        }",
			"        pushdown(u);",
			"        int mid = tr[u].l + tr[u].r >> 1;",
			"        if(r <= mid) return query(u << 1, l, r);",
			"        else if (l > mid) return query(u << 1 | 1, l, r);",
			"        else {",
			"            node res, left, right;",
			"            left = query(u << 1, l, r);",
			"            right = query(u << 1 | 1, l, r);",
			"            pushup(res, left, right);",
			"            return res;",
			"        }",
			"    }",
			"};",			
		],
		"description": "SegTree"
	},
}